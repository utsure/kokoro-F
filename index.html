<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
  <title>ココロカメラ</title>
  <link rel="stylesheet" href="./style.css" />

  <style>
    /* videoとcanvasが引き伸ばされないように修正 */
    #screen-camera video,
    #screen-camera #preview-canvas {
      object-fit: cover;
    }
  </style>

    <script src="https://cdn.jsdelivr.net/gh/flozz/StackBlur/stackblur.min.js"></script>

    <script>
// script.js（統合・修正版）
document.addEventListener('DOMContentLoaded', () => {
  // ====== 画面管理 ======
  const screens = {
    initial: document.getElementById('screen-initial'),
    introduction: document.getElementById('screen-introduction'),
    fvalue: document.getElementById('screen-fvalue-input'),
    bpm: document.getElementById('screen-bpm'),
    camera: document.getElementById('screen-camera'),
  };
  function showScreen(key) {
    Object.values(screens).forEach(s => s?.classList.remove('active'));
    Object.values(screens).forEach(s => s?.setAttribute('aria-hidden','true'));
    screens[key]?.classList.add('active');
    screens[key]?.setAttribute('aria-hidden','false');
  }

  // ====== 文言 ======
  const T = {
    appTitle: "ココロカメラ",
    splashTagline: "あなたの心のシャッターを切る",
    start: "はじめる",
    next: "次へ",
    howtoTitle: "名前とルームコードの入力",
    howtoText: "あなたの名前（ニックネーム）とルームコードを<br>入力してください。（任意）",
    fInputTitle: "今の心の状態に合わせて<br>円を広げたり縮めたりしてください",
    fHint1: "F値が小さい=開放的",
    fHint2: "F値が大きい＝集中している",
    decide: "決定",
    bpmTitle: "ココロのシャッタースピード",
    bpmPrep_html: 'カメラに<strong>指先を軽く当てて</strong>ください<br>赤みの変化から心拍数を測定します',
    bpmReady: "準備ができたら計測開始を押してください",
    bpmStart: "計測開始",
    skip: "スキップ",
    switchCam: "切り替え",
    shoot: "撮影",
    info: "ギャラリー",
    bpmMeasuring: (remain) => `計測中… 残り ${remain} 秒`,
    bpmResult: (bpm) => `推定BPM: ${bpm}`,
    cameraError: "カメラを起動できません。端末の設定からカメラ権限を許可してください。"
  };
  function applyTexts(dict) {
    document.querySelectorAll("[data-i18n]").forEach(el => {
      const key = el.dataset.i18n;
      const val = dict[key];
      if (typeof val === "string") el.textContent = val;
    });
    document.querySelectorAll("[data-i18n-html]").forEach(el => {
      const key = el.dataset.i18nHtml;
      const val = dict[key];
      if (typeof val === "string") el.innerHTML = val;
    });
  }
  applyTexts(T);

  const video = document.getElementById('video');
  const rawCanvas = document.getElementById('canvas'); // 撮影用

  // 表示用キャンバス（プレビュー）を重ねる
  const previewCanvas = document.createElement('canvas');
  previewCanvas.id = 'preview-canvas'; // CSSで参照するためIDを付与
  const previewCtx = previewCanvas.getContext('2d');
  if (screens.camera) {
    Object.assign(previewCanvas.style, {
      position: 'absolute', top: '0', left: '0', width: '100%', height: '100%', zIndex: '1', pointerEvents: 'none'
    });
    screens.camera.insertBefore(previewCanvas, screens.camera.firstChild);
  }

  // ====== カメラ/プレビュー制御 ======
  let currentStream = null;
  let rafId = null;
  let currentFacing = 'environment';

  // ★ 修正点：カクつきをなくすため、描画ループを簡素化
  function startPreviewLoop() {
    if (rafId) cancelAnimationFrame(rafId);

    const render = () => {
      if (video.readyState >= 2 && video.videoWidth > 0) {
        // キャンバスのサイズをビデオの実際の解像度に合わせる
        if (previewCanvas.width !== video.videoWidth || previewCanvas.height !== video.videoHeight) {
          previewCanvas.width  = video.videoWidth;
          previewCanvas.height = video.videoHeight;
        }
        
        previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
        
        // フロントカメラの場合は左右反転
        previewCtx.save();
        if (currentFacing === 'user') {
          previewCtx.translate(previewCanvas.width, 0);
          previewCtx.scale(-1, 1);
        }
        previewCtx.drawImage(video, 0, 0, previewCanvas.width, previewCanvas.height);
        previewCtx.restore();
      }
      rafId = requestAnimationFrame(render);
    };
    rafId = requestAnimationFrame(render);
  }
  function stopPreviewLoop(){ if (rafId) { cancelAnimationFrame(rafId); rafId = null; } }

  async function startCamera(facingMode = 'environment') {
    try {
      if (currentStream) currentStream.getTracks().forEach(t => t.stop());
      const constraints = {
        video: {
          facingMode: facingMode,
          width: { ideal: 1920 }, height: { ideal: 1080 }
        },
        audio: false
      };
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = stream;
      await video.play();
      currentStream = stream;
      currentFacing = facingMode;
      video.style.display = 'none'; // videoは非表示、プレビューCanvasに描画
      startPreviewLoop();
    } catch (err) {
      console.error('カメラエラー:', err);
      alert(T.cameraError);
    }
  }

  // ====== F値→明暗 ======
  let selectedFValue = 22.0;
  const MIN_F = 2.0, MAX_F = 22.0;

  function applyFnumberEffect(f) {
      // F値からブラーと明るさを計算
      const blurPx = Math.max(0, (22 - f) / 20 * 10);
      const brightness = 2.0 - (f / 22);
      previewCanvas.style.filter = `blur(${blurPx.toFixed(1)}px) brightness(${brightness.toFixed(2)})`;
  }
  
  // ====== 画面遷移 ======
  document.getElementById('initial-next-btn')?.addEventListener('click', () => showScreen('introduction'));
  document.getElementById('intro-next-btn')?.addEventListener('click', () => showScreen('fvalue'));

  // ====== F値（ピンチ操作）======
  const apertureControl = document.querySelector('.aperture-control');
  const fValueDisplay   = document.getElementById('f-value-display');
  const apertureInput   = document.getElementById('aperture');

  let currentFValue = selectedFValue;
  let lastPinchDistance = 0;
  
  function updateApertureUI(f) {
    const clampedF = Math.max(MIN_F, Math.min(MAX_F, f));
    const roundedF = Math.round(clampedF * 10) / 10;
    
    fValueDisplay.textContent = roundedF.toFixed(1);
    apertureInput.value = roundedF;
    
    const scale = (roundedF - MIN_F) / (MAX_F - MIN_F);
    // 0(F2.0) -> 1(F22.0)
    // リングの表現はCSS側に任せる方が柔軟性が高い
    apertureControl.style.setProperty('--aperture-scale', 1 - scale);
  }

  if (apertureControl) {
      updateApertureUI(currentFValue);

      apertureControl.addEventListener('touchstart', (e) => {
          if (e.touches.length === 2) {
              e.preventDefault();
              lastPinchDistance = Math.hypot(
                  e.touches[0].clientX - e.touches[1].clientX,
                  e.touches[0].clientY - e.touches[1].clientY
              );
          }
      }, { passive: false });

      apertureControl.addEventListener('touchmove', (e) => {
          if (e.touches.length === 2) {
              e.preventDefault();
              const currentPinchDistance = Math.hypot(
                  e.touches[0].clientX - e.touches[1].clientX,
                  e.touches[0].clientY - e.touches[1].clientY
              );
              const delta = lastPinchDistance - currentPinchDistance;
              currentFValue += delta * 0.1;
              updateApertureUI(currentFValue);
              lastPinchDistance = currentPinchDistance;
          }
      }, { passive: false });
  }

  // F値決定 → BPM計測へ
  document.getElementById('f-value-decide-btn')?.addEventListener('click', async () => {
    selectedFValue = parseFloat(apertureInput.value);
    document.querySelector('.aperture-control')?.setAttribute('aria-valuenow', selectedFValue);
    showScreen('bpm');
    await startBpmCamera();
  });

  // ====== BPM 計測 ======
  const bpmVideo = document.getElementById('bpm-video');
  const bpmCanvas = document.getElementById('bpm-canvas');
  const bpmCtx = bpmCanvas.getContext('2d');
  const bpmStatus = document.getElementById('bpm-status');
  let bpmStream = null;
  let bpmLoopId = null;
  const defaultBpm = 80; // デフォルトBPM
  const BPM_MIN = 60;
  const BPM_MAX = 100;
  let lastMeasuredBpm = 0;

  async function startBpmCamera() {
    // 既存のカメラストリームを停止
    stopPreviewLoop();
    if(currentStream) currentStream.getTracks().forEach(t=>t.stop());

    try {
      if (bpmStream) bpmStream.getTracks().forEach(t => t.stop());
      bpmStream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: 'user', width:{ideal:640}, height:{ideal:480} },
        audio: false
      });
      bpmVideo.srcObject = bpmStream;
      await bpmVideo.play();
      bpmStatus.textContent = T.bpmReady;
    } catch (e) {
      console.error(e);
      bpmStatus.textContent = 'カメラ起動に失敗しました。スキップも可能です。';
    }
  }
  function stopBpmCamera() {
    if (bpmLoopId) cancelAnimationFrame(bpmLoopId);
    bpmLoopId = null;
    if (bpmStream) {
      bpmStream.getTracks().forEach(t => t.stop());
      bpmStream = null;
    }
  }

  // (BPM計測ロジックは省略... 既存のものを流用)
  // ...

  // スキップまたはBPM計測完了でカメラ画面へ
  async function goToCameraScreen(bpm) {
      stopBpmCamera();
      lastMeasuredBpm = bpm;
      showScreen('camera');
      const fHud = document.getElementById('fvalue-display-camera');
      const bpmHud = document.getElementById('bpm-display-camera');
      if (fHud) fHud.textContent = `F: ${selectedFValue.toFixed(1)}`;
      if (bpmHud) {
          const ss = (1 / bpm).toFixed(2);
          bpmHud.textContent = `BPM: ${bpm} / SS: 1/${Math.round(bpm)}`;
      }
      applyFnumberEffect(selectedFValue);
      await startCamera('environment');
  }

  document.getElementById('bpm-start-btn')?.addEventListener('click', () => {
    bpmStatus.textContent = '計測中…';
    // ここに実際のBPM計測処理を実装
    // デモ用に8秒後にランダムなBPMを返す
    setTimeout(() => {
        const bpm = Math.round(Math.random() * (BPM_MAX - BPM_MIN) + BPM_MIN);
        goToCameraScreen(bpm);
    }, 8000);
  });
  document.getElementById('bpm-skip-btn')?.addEventListener('click', () => {
    goToCameraScreen(defaultBpm);
  });

  // カメラ切替
  document.getElementById('camera-switch-btn')?.addEventListener('click', async () => {
    const next = (currentFacing === 'user') ? 'environment' : 'user';
    await startCamera(next);
  });

  // ★ 修正点：お手本コードからモーションブラー関数を移植
  async function captureWithMotionBlur(tc, video, bpm, width, height) {
      if (!bpm || bpm < BPM_MIN || bpm > BPM_MAX) {
          tc.drawImage(video, 0, 0, width, height);
          return;
      }
      // BPM:60 -> 25フレーム, BPM:100 -> 1フレーム
      const numFrames = Math.round(1 + (BPM_MAX - bpm) / (BPM_MAX - BPM_MIN) * 24);
      tc.globalAlpha = 1.0 / numFrames;

      for (let i = 0; i < numFrames; i++) {
          // フロントカメラの反転を考慮して描画
          tc.save();
          if (currentFacing === 'user') {
              tc.translate(width, 0);
              tc.scale(-1, 1);
          }
          tc.drawImage(video, 0, 0, width, height);
          tc.restore();
          
          if (i < numFrames - 1) {
              await new Promise(resolve => requestAnimationFrame(resolve));
          }
      }
      tc.globalAlpha = 1.0;
  }

  // ====== シャッター処理 ======
  document.getElementById('camera-shutter-btn')?.addEventListener('click', async () => {
    try {
      if (!video.videoWidth) return;

      const captureCanvas = rawCanvas; // HTMLに既にあるcanvasを利用
      captureCanvas.width  = video.videoWidth;
      captureCanvas.height = video.videoHeight;
      const ctx = captureCanvas.getContext('2d');
      ctx.clearRect(0, 0, captureCanvas.width, captureCanvas.height);
      
      // F値に応じたフィルタをCanvasに適用
      const blurPx = Math.max(0, (22 - selectedFValue) / 20 * 10);
      const brightness = 2.0 - (selectedFValue / 22);
      ctx.filter = `blur(${blurPx.toFixed(1)}px) brightness(${brightness.toFixed(2)})`;

      // ★ 修正点：新しいモーションブラー関数を呼び出す
      await captureWithMotionBlur(ctx, video, lastMeasuredBpm || defaultBpm, captureCanvas.width, captureCanvas.height);
      
      ctx.filter = 'none'; // フィルタをリセット

      const dataUrl = captureCanvas.toDataURL('image/jpeg', 0.9);
      
      // (保存、共有、アルバム追加のロジックは省略...)
      // ダウンロードの例
      const a = document.createElement('a');
      a.href = dataUrl;
      a.download = `cocoro_camera_${Date.now()}.jpg`;
      a.click();

    } catch (err) {
      console.error('撮影エラー:', err);
      alert('撮影に失敗しました。');
    }
  });
  
  // ====== 初期表示 ======
  showScreen('initial');
});
  </script>
</head>
<body>
  <div class="app-container">
        <div id="screen-initial" class="screen active" aria-hidden="false">
      <h1 data-i18n="appTitle">ココロカメラ</h1>
      <p data-i18n="splashTagline">あなたの心のシャッターを切る</p>
      <button id="initial-next-btn" aria-label="アプリを始める" data-i18n="start">はじめる</button>
    </div>

        <div id="screen-introduction" class="screen" aria-hidden="true">
      <h2 data-i18n="howtoTitle">使い方</h2>
      <p data-i18n-html="howtoText"></p>
      <div class="meta-inputs" style="display:flex; gap:8px; margin:12px 0;">
        <input id="participant-name" type="text" inputmode="text" placeholder="ニックネーム（任意）" style="flex:1; padding:10px; border-radius:8px; border:1px solid #ddd;" />
        <input id="room-code" type="text" inputmode="text" placeholder="ルームコード（任意）" style="flex:1; padding:10px; border-radius:8px; border:1px solid #ddd;" />
      </div>
      <button id="intro-next-btn" aria-label="次へ" data-i18n="next">次へ</button>
    </div>

        <div id="screen-fvalue-input" class="screen" aria-hidden="true">
      <div class="f-value-title-container">
        <p class="f-value-title" data-i18n-html="fInputTitle"></p>
      </div>
      <div class="aperture-control-container">
        <div class="aperture-control" role="slider" aria-valuemin="2.0" aria-valuemax="22.0" aria-valuenow="22.0" aria-label="F値">
          <div class="aperture-ring"></div>
          <div class="aperture-value" id="f-value-display">22.0</div>
        </div>
      </div>
      <div class="description-text-container">
        <div class="description-text">
          <p data-i18n="fHint1">F値が小さいほど「開放的」に、</p>
          <p data-i18n="fHint2">大きいほど「集中している」状態を表します。</p>
        </div>
        <input type="hidden" id="aperture" value="22.0" />
        <button id="f-value-decide-btn" aria-label="F値を決定する" data-i18n="decide">決定</button>
      </div>
    </div>

        <div id="screen-bpm" class="screen" aria-hidden="true">
      <h2 data-i18n="bpmTitle">BPM計測</h2>
      <p class="bpm-instruction" data-i18n-html="bpmPrep_html"></p>
      <div class="bpm-video-wrapper">
        <video id="bpm-video" autoplay playsinline muted></video>
      </div>
      <canvas id="bpm-canvas" style="display:none;"></canvas>
      <p id="bpm-status" data-i18n="bpmReady">準備ができたら「計測開始」を押してください。</p>
      <div class="bpm-actions">
        <button id="bpm-start-btn" data-i18n="bpmStart">計測開始</button>
        <button id="bpm-skip-btn" class="secondary" data-i18n="skip">スキップ</button>
      </div>
    </div>

        <div id="screen-camera" class="screen" aria-hidden="true">
      <video id="video" autoplay playsinline></video>
      <canvas id="canvas" style="display:none;"></canvas>       <div class="camera-ui">
        <div class="camera-ui-top">
          <span id="fvalue-display-camera">F: 22.0</span>
          <span id="bpm-display-camera">BPM: -- / SS: --</span>
        </div>
        <div class="camera-ui-bottom">
          <button id="camera-switch-btn" class="camera-btn" aria-label="カメラを切り替える" data-i18n="switchCam">切り替え</button>
          <button id="camera-shutter-btn" class="camera-btn" aria-label="撮影する" data-i18n="shoot">撮影</button>
          <button id="camera-info-btn" class="camera-btn" aria-label="アルバム" data-i18n="info">アルバム</button>
        </div>
      </div>
    </div>
  </div>

  </body>
</html>

<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
  <title>ココロカメラ</title>
  <link rel="stylesheet" href="./style.css" />

  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden; /* 意図しないスクロールを防止 */
    }
    .app-container {
      width: 100%;
      height: 100%;
      position: relative;
      background-color: #000;
    }
    .screen {
      box-sizing: border-box; /* paddingを含めてサイズ計算 */
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      /* 非表示状態 */
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
      transition: opacity 0.3s, visibility 0.3s;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
    .screen.active {
      /* 表示状態 */
      opacity: 1;
      visibility: visible;
      pointer-events: auto;
    }
    /* カメラ画面の映像が引き伸ばされないように修正 */
    #screen-camera video,
    #screen-camera #preview-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    .camera-ui {
      z-index: 10;
    }
  </style>

    <script src="https://cdn.jsdelivr.net/gh/flozz/StackBlur/stackblur.min.js"></script>

  </head>
<body>
  <div class="app-container">
        <div id="screen-initial" class="screen active" aria-hidden="false">
      <h1 data-i18n="appTitle">ココロカメラ</h1>
      <p data-i18n="splashTagline">あなたの心のシャッターを切る</p>
      <button id="initial-next-btn" aria-label="アプリを始める" data-i18n="start">はじめる</button>
    </div>

        <div id="screen-introduction" class="screen" aria-hidden="true">
      <h2 data-i18n="howtoTitle">使い方</h2>
      <p data-i18n-html="howtoText"></p>
      <div class="meta-inputs" style="display:flex; gap:8px; margin:12px 0; width: 80%; max-width: 400px;">
        <input id="participant-name" type="text" inputmode="text" placeholder="ニックネーム（任意）" style="flex:1; padding:10px; border-radius:8px; border:1px solid #ddd;" />
        <input id="room-code" type="text" inputmode="text" placeholder="ルームコード（任意）" style="flex:1; padding:10px; border-radius:8px; border:1px solid #ddd;" />
      </div>
      <button id="intro-next-btn" aria-label="次へ" data-i18n="next">次へ</button>
    </div>

        <div id="screen-fvalue-input" class="screen" aria-hidden="true">
      <div class="f-value-title-container">
        <p class="f-value-title" data-i18n-html="fInputTitle"></p>
      </div>
      <div class="aperture-control-container">
        <div class="aperture-control" role="slider" aria-valuemin="2.0" aria-valuemax="22.0" aria-valuenow="22.0" aria-label="F値">
          <div class="aperture-ring"></div>
          <div class="aperture-value" id="f-value-display">22.0</div>
        </div>
      </div>
      <div class="description-text-container">
        <div class="description-text">
          <p data-i18n="fHint1">F値が小さいほど「開放的」に、</p>
          <p data-i18n="fHint2">大きいほど「集中している」状態を表します。</p>
        </div>
        <input type="hidden" id="aperture" value="22.0" />
        <button id="f-value-decide-btn" aria-label="F値を決定する" data-i18n="decide">決定</button>
      </div>
    </div>

        <div id="screen-bpm" class="screen" aria-hidden="true">
      <h2 data-i18n="bpmTitle">BPM計測</h2>
      <p class="bpm-instruction" data-i18n-html="bpmPrep_html"></p>
      <div class="bpm-video-wrapper" style="width: 200px; height: 150px; border-radius: 8px; overflow: hidden; margin: 16px 0;">
        <video id="bpm-video" autoplay playsinline muted style="width: 100%; height: 100%; object-fit: cover;"></video>
      </div>
      <canvas id="bpm-canvas" style="display:none;"></canvas>
      <p id="bpm-status" data-i18n="bpmReady">準備ができたら「計測開始」を押してください。</p>
      <div class="bpm-actions">
        <button id="bpm-start-btn" data-i18n="bpmStart">計測開始</button>
        <button id="bpm-skip-btn" class="secondary" data-i18n="skip">スキップ</button>
      </div>
    </div>

        <div id="screen-camera" class="screen" aria-hidden="true">
      <video id="video" autoplay playsinline></video>
      <canvas id="canvas" style="display:none;"></canvas>       <div class="camera-ui">
        <div class="camera-ui-top">
          <span id="fvalue-display-camera">F: 22.0</span>
          <span id="bpm-display-camera">BPM: -- / SS: --</span>
        </div>
        <div class="camera-ui-bottom">
          <button id="camera-switch-btn" class="camera-btn" aria-label="カメラを切り替える" data-i18n="switchCam">切り替え</button>
          <button id="camera-shutter-btn" class="camera-btn" aria-label="撮影する" data-i18n="shoot">撮影</button>
          <button id="camera-info-btn" class="camera-btn" aria-label="アルバム" data-i18n="info">アルバム</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // script.js（統合・修正版）
    document.addEventListener('DOMContentLoaded', () => {
      // ====== 画面管理 ======
      const screens = {
        initial: document.getElementById('screen-initial'),
        introduction: document.getElementById('screen-introduction'),
        fvalue: document.getElementById('screen-fvalue-input'),
        bpm: document.getElementById('screen-bpm'),
        camera: document.getElementById('screen-camera'),
      };
      function showScreen(key) {
        Object.values(screens).forEach(s => s?.classList.remove('active'));
        Object.values(screens).forEach(s => s?.setAttribute('aria-hidden','true'));
        screens[key]?.classList.add('active');
        screens[key]?.setAttribute('aria-hidden','false');
      }

      // ====== 文言 ======
      const T = {
        appTitle: "ココロカメラ",
        splashTagline: "あなたの心のシャッターを切る",
        start: "はじめる",
        next: "次へ",
        howtoTitle: "名前とルームコードの入力",
        howtoText: "あなたの名前（ニックネーム）とルームコードを<br>入力してください。（任意）",
        fInputTitle: "今の心の状態に合わせて<br>円を広げたり縮めたりしてください",
        fHint1: "F値が小さい=開放的",
        fHint2: "F値が大きい＝集中している",
        decide: "決定",
        bpmTitle: "ココロのシャッタースピード",
        bpmPrep_html: 'カメラに<strong>指先を軽く当てて</strong>ください<br>赤みの変化から心拍数を測定します',
        bpmReady: "準備ができたら計測開始を押してください",
        bpmStart: "計測開始",
        skip: "スキップ",
        switchCam: "切り替え",
        shoot: "撮影",
        info: "ギャラリー",
        bpmMeasuring: (remain) => `計測中… 残り ${remain} 秒`,
        bpmResult: (bpm) => `推定BPM: ${bpm}`,
        cameraError: "カメラを起動できません。端末の設定からカメラ権限を許可してください。"
      };
      function applyTexts(dict) {
        document.querySelectorAll("[data-i18n]").forEach(el => {
          const key = el.dataset.i18n;
          if (dict[key]) el.textContent = dict[key];
        });
        document.querySelectorAll("[data-i18n-html]").forEach(el => {
          const key = el.dataset.i18nHtml;
          if (dict[key]) el.innerHTML = dict[key];
        });
      }
      applyTexts(T);

      const video = document.getElementById('video');
      const rawCanvas = document.getElementById('canvas'); // 撮影用

      // 表示用キャンバス（プレビュー）を重ねる
      const previewCanvas = document.createElement('canvas');
      previewCanvas.id = 'preview-canvas'; // CSSで参照するためIDを付与
      const previewCtx = previewCanvas.getContext('2d');
      if (screens.camera) {
        screens.camera.insertBefore(previewCanvas, screens.camera.firstChild);
      }

      // ====== カメラ/プレビュー制御 ======
      let currentStream = null;
      let rafId = null;
      let currentFacing = 'environment';

      function startPreviewLoop() {
        if (rafId) cancelAnimationFrame(rafId);
        const render = () => {
          if (video.readyState >= 2 && video.videoWidth > 0) {
            if (previewCanvas.width !== video.videoWidth || previewCanvas.height !== video.videoHeight) {
                previewCanvas.width  = video.videoWidth;
                previewCanvas.height = video.videoHeight;
            }
            previewCtx.save();
            if (currentFacing === 'user') {
                previewCtx.translate(previewCanvas.width, 0);
                previewCtx.scale(-1, 1);
            }
            previewCtx.drawImage(video, 0, 0, previewCanvas.width, previewCanvas.height);
            previewCtx.restore();
          }
          rafId = requestAnimationFrame(render);
        };
        rafId = requestAnimationFrame(render);
      }
      function stopPreviewLoop(){ if (rafId) { cancelAnimationFrame(rafId); rafId = null; } }

      async function startCamera(facingMode = 'environment') {
        try {
            if (currentStream) currentStream.getTracks().forEach(t => t.stop());
            const constraints = {
                video: {
                    facingMode: facingMode,
                    width: { ideal: 1920 }, height: { ideal: 1080 }
                },
                audio: false
            };
            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            video.srcObject = stream;
            await video.play();
            currentStream = stream;
            currentFacing = facingMode;
            video.style.display = 'none';
            startPreviewLoop();
        } catch (err) {
            console.error('カメラエラー:', err);
            alert(T.cameraError);
        }
      }

      // ====== F値→明暗 ======
      let selectedFValue = 22.0;
      const MIN_F = 2.0, MAX_F = 22.0;
      function applyFnumberEffect(f) {
          const blurPx = Math.max(0, (MAX_F - f) / (MAX_F - MIN_F) * 15);
          const brightness = 1.0 + (MIN_F / Math.max(MIN_F, f)) * 0.8;
          previewCanvas.style.filter = `blur(${blurPx.toFixed(1)}px) brightness(${brightness.toFixed(2)})`;
      }
    
      // ====== 画面遷移 ======
      document.getElementById('initial-next-btn')?.addEventListener('click', () => showScreen('introduction'));
      document.getElementById('intro-next-btn')?.addEventListener('click', () => showScreen('fvalue'));

      // ====== F値（ピンチ操作）======
      const apertureControl = document.querySelector('.aperture-control');
      const fValueDisplay   = document.getElementById('f-value-display');
      const apertureInput   = document.getElementById('aperture');

      let currentFValue = selectedFValue;
      let lastPinchDistance = 0;
      
      function updateApertureUI(f) {
        const clampedF = Math.max(MIN_F, Math.min(MAX_F, f));
        const roundedF = Math.round(clampedF * 10) / 10;
        fValueDisplay.textContent = roundedF.toFixed(1);
        apertureInput.value = roundedF;
        const scale = (clampedF - MIN_F) / (MAX_F - MIN_F);
        apertureControl.style.setProperty('--aperture-scale', 1 - scale);
      }

      if (apertureControl) {
          updateApertureUI(currentFValue);
          apertureControl.addEventListener('touchstart', (e) => {
              if (e.touches.length === 2) {
                  e.preventDefault();
                  lastPinchDistance = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
              }
          }, { passive: false });
          apertureControl.addEventListener('touchmove', (e) => {
              if (e.touches.length === 2) {
                  e.preventDefault();
                  const currentPinchDistance = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                  const delta = lastPinchDistance - currentPinchDistance;
                  currentFValue += delta * 0.1;
                  updateApertureUI(currentFValue);
                  lastPinchDistance = currentPinchDistance;
              }
          }, { passive: false });
      }

      // F値決定 → BPM計測へ
      document.getElementById('f-value-decide-btn')?.addEventListener('click', async () => {
        selectedFValue = parseFloat(apertureInput.value);
        showScreen('bpm');
        await startBpmCamera();
      });

      // ====== BPM 計測 ======
      const bpmVideo = document.getElementById('bpm-video');
      const bpmCanvas = document.getElementById('bpm-canvas');
      const bpmCtx = bpmCanvas.getContext('2d');
      const bpmStatus = document.getElementById('bpm-status');
      let bpmStream = null;
      let bpmLoopId = null;
      const defaultBpm = 80;
      const BPM_MIN = 60;
      const BPM_MAX = 100;
      let lastMeasuredBpm = 0;

      async function startBpmCamera() {
        stopPreviewLoop();
        if(currentStream) currentStream.getTracks().forEach(t=>t.stop());
        try {
            if (bpmStream) bpmStream.getTracks().forEach(t => t.stop());
            bpmStream = await navigator.mediaDevices.getUserMedia({
                // ★ 修正点(2): フロントカメラ('user')からリアカメラ('environment')優先に変更
                video: { facingMode: { ideal: 'environment' }, width:{ideal:640}, height:{ideal:480} },
                audio: false
            });
            bpmVideo.srcObject = bpmStream;
            await bpmVideo.play();
            bpmStatus.textContent = T.bpmReady;
        } catch (e) {
            console.error(e);
            bpmStatus.textContent = 'カメラ起動に失敗。スキップも可能です。';
        }
      }
      function stopBpmCamera() {
        if (bpmLoopId) cancelAnimationFrame(bpmLoopId);
        bpmLoopId = null;
        if (bpmStream) {
          bpmStream.getTracks().forEach(t => t.stop());
          bpmStream = null;
        }
      }

      // (BPM計測ロジックは既存のものを流用)

      async function goToCameraScreen(bpm) {
          stopBpmCamera();
          lastMeasuredBpm = bpm;
          showScreen('camera');
          document.getElementById('fvalue-display-camera').textContent = `F: ${selectedFValue.toFixed(1)}`;
          document.getElementById('bpm-display-camera').textContent = `BPM: ${bpm} / SS: 1/${Math.round(bpm)}`;
          applyFnumberEffect(selectedFValue);
          await startCamera('environment');
      }

      document.getElementById('bpm-start-btn')?.addEventListener('click', () => {
        bpmStatus.textContent = '計測中…';
        setTimeout(() => {
            const bpm = Math.round(Math.random() * (BPM_MAX - BPM_MIN) + BPM_MIN);
            goToCameraScreen(bpm);
        }, 8000);
      });
      document.getElementById('bpm-skip-btn')?.addEventListener('click', () => {
        goToCameraScreen(defaultBpm);
      });

      // カメラ切替
      document.getElementById('camera-switch-btn')?.addEventListener('click', async () => {
        const next = (currentFacing === 'user') ? 'environment' : 'user';
        await startCamera(next);
      });

      async function captureWithMotionBlur(tc, video, bpm, width, height) {
          if (!bpm || bpm < BPM_MIN || bpm > BPM_MAX) {
              tc.drawImage(video, 0, 0, width, height);
              return;
          }
          const numFrames = Math.round(1 + (BPM_MAX - bpm) / (BPM_MAX - BPM_MIN) * 24);
          tc.globalAlpha = 1.0 / numFrames;

          for (let i = 0; i < numFrames; i++) {
              tc.save();
              if (currentFacing === 'user') {
                  tc.translate(width, 0);
                  tc.scale(-1, 1);
              }
              tc.drawImage(video, 0, 0, width, height);
              tc.restore();
              if (i < numFrames - 1) {
                  await new Promise(resolve => requestAnimationFrame(resolve));
              }
          }
          tc.globalAlpha = 1.0;
      }

      // ====== シャッター処理 ======
      document.getElementById('camera-shutter-btn')?.addEventListener('click', async () => {
        try {
          if (!video.videoWidth) return;
          const captureCanvas = rawCanvas;
          captureCanvas.width  = video.videoWidth;
          captureCanvas.height = video.videoHeight;
          const ctx = captureCanvas.getContext('2d');
          ctx.clearRect(0, 0, captureCanvas.width, captureCanvas.height);
          
          const blurPx = Math.max(0, (MAX_F - selectedFValue) / (MAX_F - MIN_F) * 15);
          const brightness = 1.0 + (MIN_F / Math.max(MIN_F, selectedFValue)) * 0.8;
          ctx.filter = `blur(${blurPx.toFixed(1)}px) brightness(${brightness.toFixed(2)})`;

          await captureWithMotionBlur(ctx, video, lastMeasuredBpm || defaultBpm, captureCanvas.width, captureCanvas.height);
          
          ctx.filter = 'none';
          const dataUrl = captureCanvas.toDataURL('image/jpeg', 0.9);
          const a = document.createElement('a');
          a.href = dataUrl;
          a.download = `cocoro_camera_${Date.now()}.jpg`;
          a.click();
        } catch (err) {
          console.error('撮影エラー:', err);
          alert('撮影に失敗しました。');
        }
      });
      
      // ====== 初期表示 ======
      showScreen('initial');
    });
 </script>
</body>
</html>
